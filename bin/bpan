#!/usr/bin/env bash

app=bpan
APP=${app^^}
[[ ${BPAN_ROOT:-} ]] ||
  { echo "BPAN_ROOT not set. 'source /path/to/$app/.rc'"; exit 1; }

source "$BPAN_ROOT/.bpan/lib/bpan.bash" --prelude

bpan:use getopt "\
$app [<options>] <cmd> [<cmd-opts...>] [<cmd-args>]

System Commands:
  search        Search for $APP packages
  install       Install a $APP package
  uninstall     Uninstall a $APP package
  list          List all installed $APP packages
  config        Manage $APP config settings
  rc            Print startup shell commands
  complete      Shell tab completion for $app

Project Commands:
  new           Create a new Bash project
  init          Create a '.$app/' project dir
  add           Add a package to a Bash project
  update        Update project $APP assets
  test          Run the project tests
  push          Push repo with tag
  register      Register a project with $APP
  publish       Publish the package to $APP
  clean         Remove the build files and dirs

Information Commands:
  help          Get help for a '$app' command
  cmds          List available '$app' commands
  upgrade       Upgrade the $APP installation

Options:
--
v,verbose     Print more output
q,quiet       Print less output

h,help        Show the command summary
V,version     Display $app version
x,debug       Print lots of debugging info
"

main() (
  get-options "$@"
  set -- "${args[@]}"

  source1 "$command"
  "$command:main" "$@"
)

get-options() {
  local getopt_default_help=false getopt_args='@args' getopt_debug=debug

  root=$BPAN_ROOT
  [[ -f $root/bin/$app ]] ||
    error "BPAN_ROOT variable has bad value '$root'"

  if [[ ${BPAN_INSTALL-} ]]; then
    [[ -d $BPAN_INSTALL ]] ||
      error "BPAN_INSTALL='$BPAN_INSTALL' - directory not found"
  else
    BPAN_INSTALL=$root/local
    export BPAN_INSTALL
  fi

  BPAN_INDEX_API_VERSION=1

  index_file=$BPAN_INSTALL/index.ini
  index_url=https://raw.githubusercontent.com/bpan-org/bpan-index/main/index.ini

  if [[ $# -eq 0 ]]; then
    set -- --help
  fi

  cmds=($(grep -E '^  \w+  ' <<<"$getopt" | cut -d' ' -f3))

  option_quiet=false
  local words=()
  while [[ $# -gt 0 ]]; do
    if [[ $1 =~ ^[a-z]+$ ]]; then
      command=$1; shift
      [[ " ${cmds[*]} " == *\ $command\ * ]] ||
        error "Invalid $app command '$command'"
      break
    fi
    words+=("$1"); shift
  done
  local cmd_opts=("$@")
  set -- "${words[@]}"

  getopt "$@"
  $option_debug && set -x

  args+=("${cmd_opts[@]}")

  if $option_version; then
    command=version
  fi

  if ! [[ ${command-} ]]; then
    if [[ ${option_server-} ]]; then
      command=server
      server_command=$option_server
      [[ $server_command =~ ^(start|stop|restart|status)$ ]] ||
        error "--server=... must be 'start', 'stop', 'restart' or 'status'"
    elif [[ ${option_run-} ]]; then
      command=run
    else
      error "You must specify a command option"
    fi
  fi

  # Get possible sub-command options:
  source1 "$command"
  if is-func "$command:getopt"; then
    unset sub_command
    local getopt_default_help=false
    local getopt_args='@args'
    local getopt_cmds
    getopt_cmds=()

    "$command:getopt"

    set -- "${args[@]}"
    args=()

    getopt='' getopt "$@" <<<"$getopt_spec"

    if [[ ${#getopt_cmds[*]} -gt 0 ]]; then
      local cmd
      for cmd in "${getopt_cmds[@]}"; do
        local var=option_$cmd
        if "${!var}"; then
          sub_command=$cmd
        fi
      done

      [[ ${sub_command-} ]] ||
        getopt -h <<<"$getopt_spec"
    fi
  fi
}

source1() {
  local var=_sourced_$1
  if [[ -z ${!var-} ]]; then
    source "$root/lib/$1.bash"
    printf -v "$var" 1
  fi
}

todo() (
  error "'$app $command' not yet implemented\n"
)

error() (
  say-r "Error: $1" >&2
  exit 1
)

# TODO Move to package say-color-bash
{
  D='\e[30m'
  R='\e[31m'
  G='\e[32m'
  Y='\e[33m'
  B='\e[34m'
  M='\e[35m'
  C='\e[36m'
  W='\e[37m'
  D1='\e[30;1m'
  R1='\e[31;1m'
  G1='\e[32;1m'
  Y1='\e[33;1m'
  B1='\e[34;1m'
  M1='\e[35;1m'
  C1='\e[36;1m'
  W1='\e[37;1m'
  Z='\e[0m'

  say-color() (
    ${option_quiet:-false} && return
    color=$1; shift
    if [[ -t 1 ]]; then
      echo -e "$Z$color$*$Z"
    else
      echo -e "$*"
    fi
  )

  say() (
    if [[ ${1-} == [-+]? ]]; then
      color=$1; shift
      "say$color" "$@"
    else
      say-color "" "$@"
    fi
  )

  say-d() ( say-color "$D" "$@" )
  say-r() ( say-color "$R" "$@" )
  say-g() ( say-color "$G" "$@" )
  say-y() ( say-color "$Y" "$@" )
  say-b() ( say-color "$B" "$@" )
  say-m() ( say-color "$M" "$@" )
  say-c() ( say-color "$C" "$@" )
  say-w() ( say-color "$W" "$@" )

  say+d() ( say-color "$D1" "$@" )
  say+r() ( say-color "$R1" "$@" )
  say+g() ( say-color "$G1" "$@" )
  say+y() ( say-color "$Y1" "$@" )
  say+b() ( say-color "$B1" "$@" )
  say+m() ( say-color "$M1" "$@" )
  say+c() ( say-color "$C1" "$@" )
  say+w() ( say-color "$W1" "$@" )
}

main "$@"
